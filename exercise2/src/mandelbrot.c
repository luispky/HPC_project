
#include <stdio.h> // For printf
#include <omp.h> // For OpenMP functions
#include "mandelbrot.h" // For the mandelbrot function

// Test if a complex number is in the Mandelbrot set
int mandelbrot(double real, double imag, int max_iterations) {
  // Initial value of the Mandelbrot sequence
  // z_0 = 0 + 0i
  double re = 0.0, im = 0.0;
  int iteration = 0;

  // Loop until the absolute value of the complex number is greater than 2
  // and the maximum number of iterations is reached
  while (SQPOWER(re, im) <=4 && iteration < max_iterations) {
    // Update the value of the Mandelbrot sequence
    // z_{n+1} = z_n^2 + c, c = real + imag * i
    double re_temp = re * re - im * im + real;
    im = 2 * re * im + imag;
    re = re_temp;

    iteration++;
  }

  // Return the number of iterations it took for the complex number to escape
  // from the Mandelbrot set
  // If the maximum number of iterations is reached, the complex number is
  // assumed to be in the Mandelbrot set
  // If the maximum number of iterations is not reached, the complex number is
  // assumed to be outside the Mandelbrot set
  return iteration;
}

void generate_mandelbrot(int n_x, int n_y,
                        int local_ny_start, int local_ny_stop,
                        double x_L, double y_L, 
                        double x_R, double y_R,
                        int I_max, void *imgPtr) {
  // Check the maximum number of iterations
  // If it is less than 256, use char data type for the image              
  if( I_max < 256 ){
    char* cimage = (char *)imgPtr;
    #pragma omp parallel for
    // Loop for a disjoint subset of the rows
    for (int y = local_ny_start; y < local_ny_stop; y++) {
      // Loop hoist the calculation of the imaginary part
      double imag = y_L + (y_R - y_L) * y / n_y;

      // Loop for the columns
      for (int x = 0; x < n_x; x++) {
        double real = x_L + (x_R - x_L) * x / n_x;
        int iterations = mandelbrot(real, imag, I_max);
        int index = (y - local_ny_start) * n_x + x;
        cimage[index] = (char)iterations;
        
      }
    }  
  } else { // If the maximum number of iterations is greater than 255, use short int data type for the image
    short int *simage = (short int *)imgPtr;
    #pragma omp parallel for
    // Loop for a disjoint subset of the rows
    for (int y = local_ny_start; y < local_ny_stop; y++) {
      // Loop hoist the calculation of the imaginary part
      double imag = y_L + (y_R - y_L) * y / n_y;

      // Loop for the columns
      for (int x = 0; x < n_x; x++) {
        double real = x_L + (x_R - x_L) * x / n_x;
        int iterations = mandelbrot(real, imag, I_max);
        int index = (y - local_ny_start) * n_x + x;
        simage[index] = (short int)iterations;
      }
    }
  }
}

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name){
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 

  // Writing the header of the PGM file
  fprintf(image_file, "P5\n# generated by\n# Luis Fernando Palacios Flores\n%d %d\n%d\n", xsize, ysize, maxval);  
  
  // The "P5" magic value is used to identify a binary (raw) Portable GrayMap (PGM) file. 
  // Format used for storing grayscale images, where each pixel is represented by a single value that can range from 0 (black) to 65535 (white). 
  // Values close to 0 are mapped to black, and values close to 65535 are mapped to white.
  // 65535 = 2^{2 bytes * 8 bits per byte} - 1 is used for short int data type. 

  // A bit depth of 8 bits allows for 256 different gray levels (0-255),
  // while a bit depth of 16 bits allows for 65,536 different gray levels (0-65,535)

  // If the maximum value is less than 256, use char data type for the image
  // Otherwise, use short int data type for the image
  int color_depth = 1 + ( maxval > 255 );
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
}