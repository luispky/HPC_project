/*
* mandelbrot.c
* 
* This program generates the Mandelbrot set and writes it to a file in PGM format.
*
* The program takes 7 arguments:
*   1. n_x: the number of pixels in the x direction
*   2. n_y: the number of pixels in the y direction
*   3. x_L: the left boundary of the x-axis
*   4. y_L: the lower boundary of the y-axis
*   5. x_R: the right boundary of the x-axis
*   6. y_R: the upper boundary of the y-axis
*   7. I_max: the maximum number of iterations
*
* If no arguments are given, the program uses the following default values:
*   n_x = 800
*   n_y = 800
*   x_L = -2.0
*   y_L = -1.0
*   x_R = 2.0
*   y_R = 1.0
*   I_max = 65535
*
* The program uses OpenMP to parallelize the generation of the Mandelbrot set.
*
* The program writes the Mandelbrot set to a file called mandelbrot.pgm.
*
* The program also prints the CPU time and wall time for the generation of the Mandelbrot set.
*
* The program uses the following functions:
*   1. mandelbrot: generates the Mandelbrot set
*   2. generate_mandelbrot: generates the Mandelbrot set and returns a pointer to the image
*   3. write_pgm_image: writes the Mandelbrot set to a file in PGM format
*
*/

// compile: gcc -o mandelbrot mandelbrot.c -fopenmp
// run: ./mandelbrot 800 800 -2.0 -2.0 2.0 2.0 65535


#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <time.h>

#define WIDTH 800
#define HEIGHT 800
#define X_L -2.0
#define Y_L -1.0
#define X_R 0.5
#define Y_R 1.0
#define MAX_ITERATIONS 65535
#define SQPOWER(zr, zi) (zr * zr + zi * zi)

int mandelbrot(double real, double imag, int max_iterations) {
  double re = 0.0, im = 0.0;
  int iteration = 0;

  while ( SQPOWER(re, im) <=4 && iteration < max_iterations) {
    double re_temp = re * re - im * im + real;
    im = 2 * re * im + imag;
    re = re_temp;

    iteration++;
  }

  return iteration;
}

void generate_mandelbrot(int n_x, int n_y, double x_L, double y_L, double x_R, double y_R, int I_max, void* imgPtr){
  if( I_max < 256 ){
    char *cImage = (char *) imgPtr;   // the image when a single byte is used for each pixel
    // cImage = (char*)calloc( n_x*n_y, sizeof(char) );
    #pragma omp parallel for
    for (int y = 0; y < n_y; y++) {
      for (int x = 0; x < n_x; x++) {
        double real = x_L + (x_R - x_L) * x / n_x;
        double imag = y_L + (y_R - y_L) * y / n_y;
        int iterations = mandelbrot(real, imag, I_max);
        cImage[y * n_x + x] = (char)iterations;
      }
    }
  } else {
    short int *sImage = (short int *) imgPtr;   // the image when two bytes are used for each pixel
    // sImage = (short int*)calloc( n_x*n_y, sizeof(short int) );
    #pragma omp parallel for
    for (int y = 0; y < n_y; y++) {
      for (int x = 0; x < n_x; x++) {
        double real = x_L + (x_R - x_L) * x / n_x;
        double imag = y_L + (y_R - y_L) * y / n_y;
        int iterations = mandelbrot(real, imag, I_max);
        sImage[y * n_x + x] = (short int)iterations;
      }
    }
  }
}

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your Luis Fernando Palacios Flores\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;
}

int main(int argc, char** argv) {
  int n_x, n_y, I_max;
  double x_L, y_L, x_R, y_R;

  if (argc > 1){
    n_x = atoi(*(argv+1));
    n_y = atoi(*(argv+2));
    x_L = atof(*(argv+3));
    y_L = atof(*(argv+4));
    x_R = atof(*(argv+5));
    y_R = atof(*(argv+6));
    I_max = atoi(*(argv+7));
  } else {
    n_x = WIDTH;
    n_y = HEIGHT;
    x_L = X_L;
    y_L = Y_L;
    x_R = X_R;
    y_R = Y_R;
    I_max = MAX_ITERATIONS;
  }

  omp_set_num_threads(12);
  
  clock_t start_cpu_parallel = clock();
  double start_wall_parallel = omp_get_wtime();

  void* ptr;
  if( I_max < 256 ){
    ptr = (char*)calloc( n_x*n_y, sizeof(char) );
  } else {
    ptr = (short int*)calloc( n_x*n_y, sizeof(short int) );
  }
  
  generate_mandelbrot(n_x, n_y, x_L, y_L, x_R, y_R, I_max, ptr);

  clock_t end_cpu_parallel = clock();
  double end_wall_parallel = omp_get_wtime();
  printf("The Mandelbrot set has been generated\n");
  printf("Parallel CPU time (s): %f\n", (double)(end_cpu_parallel - start_cpu_parallel) / CLOCKS_PER_SEC);
  printf("Parallel Wall time (s): %f\n", end_wall_parallel - start_wall_parallel);
  printf("\n");

  write_pgm_image(ptr, I_max, n_x, n_y, "../plots/mandelbrot.pgm");
  printf("The Mandelbrot set has been written\n");

  free(ptr);

  return 0;
}
