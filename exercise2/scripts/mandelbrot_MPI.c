/*
* Mandelbrot Set Generation using MPI and OpenMP
* Author: Luis Fernando Palacios Flores
* Date: February 2024
*/

// compile with: mpicc -fopenmp mandelbrot_MPI.c -o mandelbrot_MPI
// run with: mpirun -np 4 ./mandelbrot_MPI 12 800 800 -2.0 -1.0 0.5 1.0 65535

#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <omp.h>
#include <time.h>

#define WIDTH 800
#define HEIGHT 800
#define X_L -2.0
#define Y_L -1.0
#define X_R 0.5
#define Y_R 1.0
#define MAX_ITERATIONS 65535
#define SQPOWER(zr, zi) (zr * zr + zi * zi)
#define N_PROC 4
#define N_THREADS 12

int mandelbrot(double real, double imag, int max_iterations) {
  double re = 0.0, im = 0.0;
  int iteration = 0;

  while (SQPOWER(re, im) <=4 && iteration < max_iterations) {
    double re_temp = re * re - im * im + real;
    im = 2 * re * im + imag;
    re = re_temp;

    iteration++;
  }

  return iteration;
}

void generate_mandelbrot(int n_x, int n_y,
                        int local_ny_start, int local_ny_stop,
                        double x_L, double y_L, 
                        double x_R, double y_R,
                        int I_max, void *imgPtr) {
  if( I_max < 256 ){
    char* cimage = (char *)imgPtr;
    // int j = 0;
    #pragma omp parallel for
    for (int y = local_ny_start; y < local_ny_stop; y++) {
      for (int x = 0; x < n_x; x++) {
        double real = x_L + (x_R - x_L) * x / n_x;
        double imag = y_L + (y_R - y_L) * y / n_y;
        int iterations = mandelbrot(real, imag, I_max);
        int index = (y - local_ny_start) * n_x + x;
        // int index = j * n_x + x;
        cimage[index] = (char)iterations;
      }
      // j++;
    }
  } else {
    short int *simage = (short int *)imgPtr;
    // int j = 0;
    #pragma omp parallel for
    for (int y = local_ny_start; y < local_ny_stop; y++) {
      for (int x = 0; x < n_x; x++) {
        double real = x_L + (x_R - x_L) * x / n_x;
        double imag = y_L + (y_R - y_L) * y / n_y;
        int iterations = mandelbrot(real, imag, I_max);
        int index = (y - local_ny_start) * n_x + x;
        // int index = j * n_x + x;
        simage[index] = (short int)iterations;
      }
      // j++;
    }
  }
}

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# Luis Fernando Palacios Flores\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;
}

int main(int argc, char** argv) {

  int mpi_provided_thread_level;
  MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);

  if (mpi_provided_thread_level < MPI_THREAD_FUNNELED) {
      printf("A problem arose when asking for MPI_THREAD_FUNNELED level\n");
      MPI_Finalize();
      exit(1);
  }

  int rank, size;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);

  int N_threads = (argc > 2) ? atoi(*(argv+2)) : N_THREADS;
  int n_x = (argc > 3) ? atoi(*(argv+3)) : WIDTH;
  int n_y = (argc > 4) ? atoi(*(argv+4)) : HEIGHT;
  double x_L = (argc > 5) ? atof(*(argv+5)) : X_L;
  double y_L = (argc > 6) ? atof(*(argv+6)) : Y_L;
  double x_R = (argc > 7) ? atof(*(argv+7)) : X_R;
  double y_R = (argc > 8) ? atof(*(argv+8)) : Y_R;
  int I_max = (argc > 9) ? atoi(*(argv+9)) : MAX_ITERATIONS;

  // Set the number of threads for OpenMP
  omp_set_dynamic(0); // Disable dynamic teams
  omp_set_num_threads(N_threads);

  // Calculate the number of rows to be computed by each process
  int local_ny = n_y / size;
  int reminder = n_y % size;
  int local_ny_start = local_ny * rank + ((rank < reminder) ? rank : reminder);
  int local_ny_stop = local_ny_start + local_ny + ((rank < reminder) ? 1 : 0);
  int sendbuf_size = (local_ny_stop - local_ny_start) * n_x;

  // Allocate memory for the image
  void *img_sendbuf = NULL;
  void *img_recvbuf = NULL;
  if (I_max <  256) {
    img_sendbuf = (char *)malloc(sendbuf_size * sizeof(char));   
    if (rank ==  0) {
      img_recvbuf = (char *)malloc(n_y * n_x * sizeof(char));
    }
  } else {
    img_sendbuf = (short int *)malloc(sendbuf_size * sizeof(short int));
    if (rank ==  0) {
      img_recvbuf = (short int *)malloc(n_y * n_x * sizeof(short int));
    }
  }

  // Record the start time
  double start_time = MPI_Wtime();
  
  // Each process generates its portion of the Mandelbrot set
  generate_mandelbrot(n_x, n_y, local_ny_start, local_ny_stop,
                      x_L, y_L, x_R, y_R,
                      I_max, img_sendbuf);

  // Prepare arrays for MPI_Gatherv
  int *recvcounts = NULL;
  int *displs = NULL;

  if (rank == 0) {
    recvcounts = (int *)malloc(size * sizeof(int));
    displs = (int *)malloc(size * sizeof(int));

    // Initialize recvcounts and displs arrays
    for (int i = 0; i < size; i++) {
      recvcounts[i] = sendbuf_size;
      displs[i] = local_ny_start * n_x;
    }
  }

  // Barrier to make sure that all processes have reached this point
  MPI_Barrier(MPI_COMM_WORLD);

  // Gather data from all processes to the root (rank 0)
  if (I_max < 256){
    MPI_Gatherv(img_sendbuf, // The send buffer
    sendbuf_size, // The number of elements to send to each process
    MPI_CHAR, // The data type of the send buffer
    img_recvbuf, // The receive buffer for this process
    recvcounts, // The count of elements each process sends
    displs, // The displacements for each process
    MPI_CHAR, // The data type of the receive buffer
    0, // The rank of the root process
    MPI_COMM_WORLD); // The communicator

  } else {
    MPI_Gatherv(img_sendbuf, // The send buffer
    sendbuf_size, // The number of elements to send to each process
    MPI_SHORT, // The data type of the send buffer
    img_recvbuf, // The receive buffer for this process
    recvcounts, // The count of elements each process sends
    displs, // The displacements for each process
    MPI_SHORT, // The data type of the receive buffer
    0, // The rank of the root process
    MPI_COMM_WORLD); // The communicator
  }

  // Record the end time
  double end_time = MPI_Wtime();

  // Calculate the total execution time
  double elapsed_time = end_time - start_time;

  // Print the timing information (only on rank 0)
  if (rank == 0) {
    printf("Total execution time: %f seconds\n", elapsed_time);
    // Print the gathered data at the root process
    write_pgm_image(img_recvbuf, I_max, n_x, n_y, "../plots/mandelbrot_MPI.pgm");
    printf("The Mandelbrot set has been written\n");

    // Free the allocated memory for img_recvbuf array and related arrays at root
    free(img_recvbuf);
    free(recvcounts);
    free(displs);
  }

  // Free the allocated memory for sendbuf array
  free(img_sendbuf);

  MPI_Finalize();

  return 0;
}